#!/bin/bash

_printf() {

  # only print if $silent is unset
  if [ -z "$silent" ]; then
    printf "$@"
  fi

}

_usage() {

  printf "Usage: $0"
  printf " [-i input_dir]"
  printf " [-I input_ext]"
  printf " [-o output_dir]"
  printf " [-O output_ext]"
  printf " [-s]"
  printf " -- run_cmd\n"

}

_error() {

  printf "$0: $1\n"
  if [ -n "$2" ]; then
    _usage
  fi
  exit 1

}

_normalise_dir() {

  # set to the default if unset
  local dir=${1:-"$2"}

  # strip the trailing '/'
  printf "${dir%/}"

}

_normalise_ext() {

  # set to the default if unset
  if [ -z "$1" ]; then
    printf ""
  else
    printf ".${1#.}"
  fi

}

not_ok() {

  local err="$3"
  _printf "not ok $1 - $2\n  ---\n  error: "

  # check if $err spans multiple lines
  if [ $(echo "$err" | wc -l) -gt 1 ]; then
    err=${err/	/  }
    err=${err/
/
    }
    _printf "|\n    $err\n";
  else
    _printf "'$err'\n"
  fi
  _printf "  ...\n"

}

# parse command line arguments
while [ "$#" -gt 0 ]; do

  # if $run_cmd is still unset
  if [ -z "$run_cmd" ]; then

    case "$1" in
      # flag options with value
      -i | -I | -o | -O | -a)
        # check that a value was specified after the flag
        if [ -z "$2" ] || [[ "$2" == -* ]]; then
          _error "option $1 expects a value"
        fi
        case "$1" in
          -i) input_dir="$2";;
          -I) input_ext="$2";;
          -o) output_dir="$2";;
          -O) output_ext="$2";;
          -a) actual_dir="$2";;
        esac
        shift
        ;;
      # flag options without value
      -s)
        silent=1
        ;;
      # non-flag options
      *)
        if [ "$1" == "--" ]; then
          if [ -z "$2" ]; then
            _error "need a run command" 1
          fi
          run_cmd="$2"
          shift
        else
          run_cmd="$1"
        fi
        ;;
    esac

  else
    run_cmd="$run_cmd $1"
  fi

  shift

done

# exit if no run command
if [ -z "$run_cmd" ]; then
  _error "need a run command" 1
fi

# normalise options
input_dir=$(_normalise_dir "$input_dir" "input")
input_ext=$(_normalise_ext "$input_ext")
output_dir=$(_normalise_dir "$output_dir" "output")
output_ext=$(_normalise_ext "$output_ext")
actual_dir=$(_normalise_dir "$actual_dir" "actual")

# exit if $input_dir or $output_dir not found
if [ ! -d "$input_dir" ]; then
  _error "$input_dir: no such directory"
fi
if [ ! -d "$output_dir" ]; then
  _error "$output_dir: no such directory"
fi

# empty $actual_dir
rm -rf "$actual_dir"
mkdir -p "$actual_dir"

# print TAP version
_printf "TAP version 13\n"

# store input file names in $input_files
num_test=0
for input_file in "$input_dir"/*"$input_ext"; do

  # only include files
  if [ -f "$input_file" ]; then
    input_files["$num_test"]="$input_file"
    ((num_test++))
  fi

done

# print TAP plan
_printf "1..$num_test\n"

# count passing tests
num_pass=0

# counter for numbering tests
i=1

# iterate over input file names in the $input_files array
for input_file in "${input_files[@]}"; do

  # resolve $input_basename and $test_name
  input_basename=$(basename "$input_file")
  test_name=${input_basename%.*}

  # resolve $output_file and $actual_file
  if [ -n "$output_ext" ]; then
    output_basename="$test_name""$output_ext"
  else
    output_basename="$input_basename"
  fi
  output_file="$output_dir"/"$output_basename"
  actual_file="$actual_dir"/"$output_basename"

  # redirect `stderr` to `stdout`, and `stdout` to $actual_file
  err=$(eval "$run_cmd" < "$input_file" 2>&1 >| "$actual_file")

  # check if $err is empty
  if [ -z "$err" ]; then

    # check if $output_file exists
    if [ -f "$output_file" ]; then

      # compare expected output with actual output
      cmp_result=$(cmp "$output_file" "$actual_file" 2>&1)

      # check if $cmp_result is empty
      if [ -z "$cmp_result" ]; then
        _printf "ok $i - $test_name\n"
        ((num_pass++))
      else
        not_ok "$i" "$test_name" "$cmp_result"
      fi

    else
      not_ok "$i" "$test_name" "$output_file: no such file"
    fi

  else
    not_ok "$i" "$test_name" "$err"
  fi

  # increment counter
  ((i++))

done

# count failing tests
num_fail=$((num_test - num_pass))

# print result summary
_printf "# tests $num_test\n"
_printf "# pass  $num_pass\n"
_printf "# fail  $num_fail\n"

# exit with code 1 if some tests failed
if [ "$num_fail" -ne 0 ]; then
  exit 1
fi
